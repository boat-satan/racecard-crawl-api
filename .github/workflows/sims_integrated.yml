name: sims_integrated

on:
  workflow_dispatch:
    inputs:
      DATE:   { description: "YYYYMMDD", required: true,  type: string }
      PID:    { description: "場コード 01..24（カンマ可, all/空=全場）", required: false, default: "all", type: string }
      MODE:   { description: "predict or eval", required: true, default: "predict", type: choice, options: [predict, eval] }
      SIMS:   { description: "試行回数/レース", required: true, default: "600", type: string }
      TOPN:   { description: "三連単 TOPN", required: true, default: "18", type: string }
      UNIT:   { description: "1点あたり(円)", required: true, default: "100", type: string }
      FILTERS: { description: "例: require_odds=true,min_ev=1.2,odds_bands=01-09,10-19", required: false, default: "", type: string }
      KEYMAN:  { description: "例: enable=true,thr=0.7,boost=0.15,aggr=0.0,buy_in_top3=false,buy_thr=0.7", required: false, default: "enable=true,thr=0.7,boost=0.15,aggr=0.0,buy_in_top3=false,buy_thr=0.7", type: string }
      OUTDIR:  { description: "出力ディレクトリ", required: false, default: "scripts/sims", type: string }

permissions:
  contents: write

concurrency:
  group: sims-integrated-${{ github.ref }}-${{ inputs.DATE }}-${{ inputs.PID }}
  cancel-in-progress: false

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          set -e
          python -m pip install --upgrade pip
          pip install numpy pandas joblib scikit-learn
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Parse FILTERS & KEYMAN
        id: parse
        env:
          FILTERS: ${{ inputs.FILTERS }}
          KEYMAN:  ${{ inputs.KEYMAN }}
        run: |
          set -euo pipefail
          mkdir -p .github
          : > .github/parsed_env

          parse_kvlist () {
            local s="$1"; local prefix="$2"
            IFS=',' read -r -a pairs <<< "$s"
            for kv in "${pairs[@]}"; do
              kv="$(echo "$kv" | tr -d '\r' | xargs)"
              [ -z "$kv" ] && continue
              if [[ "$kv" == *"="* ]]; then
                k="$(echo "${kv%%=*}" | tr '[:lower:]' '[:upper:]' | tr -c 'A-Z0-9_' '_' | xargs)"
                v="$(echo "${kv#*=}" | tr -d '\r' | xargs)"
                # outputs
                echo "$prefix$k=$v" >> "$GITHUB_OUTPUT"
                # env file for later `source`
                printf '%s=%s\n' "$prefix$k" "$v" >> .github/parsed_env
              fi
            done
          }

          # defaults -> both GITHUB_OUTPUT and parsed_env
          for line in \
            "F_REQUIRE_ODDS=false" "F_MIN_EV=0" "F_ODDS_BANDS=" "F_ODDS_MIN=0" "F_ODDS_MAX=0" \
            "F_EXCLUDE_FIRST1=false" "F_ONLY_FIRST1=false" "F_BUY_IN_TOP3=false" "F_BUY_THR=0.7" \
            "K_ENABLE=true" "K_THR=0.7" "K_BOOST=0.15" "K_AGGR=0.0"
          do
            echo "$line" >> "$GITHUB_OUTPUT"
            echo "$line" >> .github/parsed_env
          done

          [ -n "${FILTERS:-}" ] && parse_kvlist "$FILTERS" "F_"
          [ -n "${KEYMAN:-}" ]  && parse_kvlist "$KEYMAN"  "K_"

          echo "[parse] wrote .github/parsed_env:"
          sed -n '1,200p' .github/parsed_env || true

      - name: Normalize PID (all/空→01..24, カンマ区切り整形)
        id: pidnorm
        env:
          PID_IN: ${{ inputs.PID }}
        run: |
          set -euo pipefail
          PID_TRIM="$(echo "${PID_IN:-}" | tr '[:space:]' ' ' | xargs)"
          if [ -z "$PID_TRIM" ] || [ "${PID_TRIM,,}" = "all" ]; then
            ALL=""
            for i in $(seq -w 01 24); do ALL="${ALL}${i},"; done
            PID_EXP="${ALL%,}"
          else
            PID_NORM="$(echo "$PID_TRIM" | tr '、，;|' ',')"
            OUT=""
            IFS=',' read -r -a arr <<< "$PID_NORM"
            for p in "${arr[@]}"; do
              p="$(echo "$p" | xargs)"; [ -z "$p" ] && continue
              printf -v two "%02d" "$p"; OUT="${OUT}${two},"
            done
            PID_EXP="${OUT%,}"
          fi
          echo "PID_EXP=$PID_EXP" | tee -a "$GITHUB_OUTPUT"
          echo "[pidnorm] => $PID_EXP"

      # 1) Pass1
      - name: Run Pass1 (keyman only)
        env:
          DATE:  ${{ inputs.DATE }}
          PID:   ${{ steps.pidnorm.outputs.PID_EXP }}
          SIMS:  ${{ inputs.SIMS }}
          TOPN:  ${{ inputs.TOPN }}
          OUTDIR: ${{ inputs.OUTDIR }}
        run: |
          set -euo pipefail
          echo "[pass1] DATE=$DATE PID=$PID"
          python scripts/sims/sims.py \
            --base public \
            --dates "$DATE" \
            --pids "$PID" \
            --sims "$SIMS" \
            --strategy trifecta_topN --topn "$TOPN" \
            --predict-only \
            --outdir "$OUTDIR"

      # 2) TENKAI (per PID)
      - name: Run TENKAI prediction
        env:
          DATE: ${{ inputs.DATE }}
          PID_EXP: ${{ steps.pidnorm.outputs.PID_EXP }}
        run: |
          set -euo pipefail
          mkdir -p "TENKAI/predictions/v1/$DATE"
          echo "[tenkai] $DATE / $PID_EXP"
          IFS=',' read -r -a PIDS <<< "$PID_EXP"
          for P in "${PIDS[@]}"; do
            P="$(echo "$P" | xargs)"; [ -z "$P" ] && continue
            echo "  -> pid=$P"
            python TENKAI/tenkai_predict_integrated.py --date "$DATE" --pid "$P"
          done

      - name: Show ML CSVs
        run: |
          find TENKAI/predictions/v1/${{ inputs.DATE }} -maxdepth 4 -type f -name '*.csv' | sort || true

      # 3) Pass2
      - name: Run Pass2 (SimS integrated with ML)
        env:
          DATE:  ${{ inputs.DATE }}
          PID:   ${{ steps.pidnorm.outputs.PID_EXP }}
          MODE:  ${{ inputs.MODE }}
          SIMS:  ${{ inputs.SIMS }}
          TOPN:  ${{ inputs.TOPN }}
          OUTDIR: ${{ inputs.OUTDIR }}
          # fallbacks from outputs (source でも入らなかった時用)
          F_REQUIRE_ODDS:   ${{ steps.parse.outputs.F_REQUIRE_ODDS }}
          F_MIN_EV:         ${{ steps.parse.outputs.F_MIN_EV }}
          F_ODDS_BANDS:     ${{ steps.parse.outputs.F_ODDS_BANDS }}
          F_ODDS_MIN:       ${{ steps.parse.outputs.F_ODDS_MIN }}
          F_ODDS_MAX:       ${{ steps.parse.outputs.F_ODDS_MAX }}
          F_EXCLUDE_FIRST1: ${{ steps.parse.outputs.F_EXCLUDE_FIRST1 }}
          F_ONLY_FIRST1:    ${{ steps.parse.outputs.F_ONLY_FIRST1 }}
          F_BUY_IN_TOP3:    ${{ steps.parse.outputs.F_BUY_IN_TOP3 }}
          F_BUY_THR:        ${{ steps.parse.outputs.F_BUY_THR }}
          K_ENABLE: ${{ steps.parse.outputs.K_ENABLE }}
          K_THR:    ${{ steps.parse.outputs.K_THR }}
          K_BOOST:  ${{ steps.parse.outputs.K_BOOST }}
          K_AGGR:   ${{ steps.parse.outputs.K_AGGR }}
        run: |
          set -euo pipefail
          # 解析済み値を必ず取り込む
          [ -f .github/parsed_env ] && source .github/parsed_env

          # フォールバック（空なら outputs 値を採用）
          : "${F_REQUIRE_ODDS:=${{ steps.parse.outputs.F_REQUIRE_ODDS }}}"
          : "${F_MIN_EV:=${{ steps.parse.outputs.F_MIN_EV }}}"
          : "${F_ODDS_BANDS:=${{ steps.parse.outputs.F_ODDS_BANDS }}}"
          : "${F_ODDS_MIN:=${{ steps.parse.outputs.F_ODDS_MIN }}}"
          : "${F_ODDS_MAX:=${{ steps.parse.outputs.F_ODDS_MAX }}}"
          : "${F_EXCLUDE_FIRST1:=${{ steps.parse.outputs.F_EXCLUDE_FIRST1 }}}"
          : "${F_ONLY_FIRST1:=${{ steps.parse.outputs.F_ONLY_FIRST1 }}}"
          : "${F_BUY_IN_TOP3:=${{ steps.parse.outputs.F_BUY_IN_TOP3 }}}"
          : "${F_BUY_THR:=${{ steps.parse.outputs.F_BUY_THR }}}"
          : "${K_ENABLE:=${{ steps.parse.outputs.K_ENABLE }}}"
          : "${K_THR:=${{ steps.parse.outputs.K_THR }}}"
          : "${K_BOOST:=${{ steps.parse.outputs.K_BOOST }}}"
          : "${K_AGGR:=${{ steps.parse.outputs.K_AGGR }}}"

          echo "[pass2] MODE=$MODE DATE=$DATE PID=$PID"
          echo "[debug] KEYMAN => enable=$K_ENABLE, thr=$K_THR, boost=$K_BOOST, aggr=$K_AGGR"
          echo "[debug] FILTERS => require_odds=$F_REQUIRE_ODDS, min_ev=$F_MIN_EV, bands='$F_ODDS_BANDS', min=$F_ODDS_MIN, max=$F_ODDS_MAX, excl1=$F_EXCLUDE_FIRST1, only1=$F_ONLY_FIRST1, buy_top3=$F_BUY_IN_TOP3, buy_thr=$F_BUY_THR"

          # 無効化指定なら数値も0化
          if [[ "${K_ENABLE,,}" == "false" ]]; then
            K_THR=9.9; K_BOOST=0; K_AGGR=0
          fi

          ARGS_COMMON="--base public --dates $DATE --pids $PID \
            --sims $SIMS --topn $TOPN \
            --keyman-threshold $K_THR --keyman-boost $K_BOOST --keyman-aggr $K_AGGR \
            --ml-root TENKAI/predictions/v1 \
            --outdir $OUTDIR"

          [[ "${F_EXCLUDE_FIRST1,,}" == "true" ]] && ARGS_COMMON="$ARGS_COMMON --exclude-first1"
          [[ "${F_ONLY_FIRST1,,}"    == "true" ]] && ARGS_COMMON="$ARGS_COMMON --only-first1"
          [[ "${F_BUY_IN_TOP3,,}"    == "true" ]] && ARGS_COMMON="$ARGS_COMMON --buy-if-keyman-in-top3 --buy-keyman-threshold $F_BUY_THR"

          if [[ "$MODE" == "predict" ]]; then
            python scripts/sims/sims_integrated.py $ARGS_COMMON --predict-only
          else
            ARGS_FILTER=""
            [[ -n "${F_ODDS_BANDS}" ]] && ARGS_FILTER="$ARGS_FILTER --odds-bands \"$F_ODDS_BANDS\""
            [[ -n "${F_ODDS_MIN}"   && "$F_ODDS_MIN" != "0" ]] && ARGS_FILTER="$ARGS_FILTER --odds-min $F_ODDS_MIN"
            [[ -n "${F_ODDS_MAX}"   && "$F_ODDS_MAX" != "0" ]] && ARGS_FILTER="$ARGS_FILTER --odds-max $F_ODDS_MAX"
            [[ "${F_REQUIRE_ODDS,,}" == "true" ]] && ARGS_FILTER="$ARGS_FILTER --require-odds"
            [[ -n "${F_MIN_EV}" && "$F_MIN_EV" != "0" ]] && ARGS_FILTER="$ARGS_FILTER --min-ev $F_MIN_EV"
            # bands のクォート保持のため eval
            eval python scripts/sims/sims_integrated.py $ARGS_COMMON --odds-base public/odds/v1 $ARGS_FILTER
          fi

      # 4) 集計：常に実行し、overall.json を毎回上書き（CSVが無い場合はゼロ埋め）
      - name: Aggregate & write overall.json (overwrite always)
        env:
          DATE:  ${{ inputs.DATE }}
          MODE:  ${{ inputs.MODE }}
          UNIT:  ${{ inputs.UNIT }}
          SIMS:  ${{ inputs.SIMS }}
          TOPN:  ${{ inputs.TOPN }}
          PID:   ${{ steps.pidnorm.outputs.PID_EXP }}
          OUTDIR: ${{ inputs.OUTDIR }}
          # filters
          F_REQUIRE_ODDS:   ${{ steps.parse.outputs.F_REQUIRE_ODDS }}
          F_MIN_EV:         ${{ steps.parse.outputs.F_MIN_EV }}
          F_ODDS_BANDS:     ${{ steps.parse.outputs.F_ODDS_BANDS }}
          F_ODDS_MIN:       ${{ steps.parse.outputs.F_ODDS_MIN }}
          F_ODDS_MAX:       ${{ steps.parse.outputs.F_ODDS_MAX }}
          F_EXCLUDE_FIRST1: ${{ steps.parse.outputs.F_EXCLUDE_FIRST1 }}
          F_ONLY_FIRST1:    ${{ steps.parse.outputs.F_ONLY_FIRST1 }}
          F_BUY_IN_TOP3:    ${{ steps.parse.outputs.F_BUY_IN_TOP3 }}
          F_BUY_THR:        ${{ steps.parse.outputs.F_BUY_THR }}
          # keyman
          K_ENABLE: ${{ steps.parse.outputs.K_ENABLE }}
          K_THR:    ${{ steps.parse.outputs.K_THR }}
          K_BOOST:  ${{ steps.parse.outputs.K_BOOST }}
          K_AGGR:   ${{ steps.parse.outputs.K_AGGR }}
        run: |
          set -euo pipefail
          CSV="$OUTDIR/pass2/per_race_results.csv"
          mkdir -p "$OUTDIR/pass2"

          python - << 'PY'
import csv, json, os
csv_path = os.environ.get("CSV")
unit = int(os.environ.get("UNIT","100"))
date = os.environ.get("DATE","")
mode = os.environ.get("MODE","")
pid  = os.environ.get("PID","")

def tf(v): return str(v).strip().lower() == "true"

opts = {
  "sims": int(os.environ.get("SIMS","0")),
  "topn": int(os.environ.get("TOPN","0")),
  "filters": {
    "require_odds": tf(os.environ.get("F_REQUIRE_ODDS","false")),
    "min_ev": float(os.environ.get("F_MIN_EV","0") or 0),
    "odds_bands": os.environ.get("F_ODDS_BANDS","") or "",
    "odds_min": float(os.environ.get("F_ODDS_MIN","0") or 0),
    "odds_max": float(os.environ.get("F_ODDS_MAX","0") or 0),
    "exclude_first1": tf(os.environ.get("F_EXCLUDE_FIRST1","false")),
    "only_first1": tf(os.environ.get("F_ONLY_FIRST1","false")),
    "buy_in_top3": tf(os.environ.get("F_BUY_IN_TOP3","false")),
    "buy_thr": float(os.environ.get("F_BUY_THR","0") or 0),
  },
  "keyman": {
    "enable": tf(os.environ.get("K_ENABLE","true")),
    "threshold": float(os.environ.get("K_THR","0.7") or 0.7),
    "boost": float(os.environ.get("K_BOOST","0.15") or 0.15),
    "aggr": float(os.environ.get("K_AGGR","0") or 0.0),
    "buy_in_top3": tf(os.environ.get("F_BUY_IN_TOP3","false")),
    "buy_thr": float(os.environ.get("F_BUY_THR","0") or 0),
  }
}

races=bets=hits=payout=stake=0

def pick(row, names):
  for n in names:
    if n in row and str(row[n]).strip() != "":
      return row[n]
  return "0"

if os.path.isfile(csv_path):
  with open(csv_path, newline="", encoding="utf-8") as f:
    rdr = csv.DictReader(f)
    for row in rdr:
      races += 1
      b = int(float(pick(row, ["bets","bet_count","n_bets"])))
      h = int(float(pick(row, ["hits","hit","n_hits"])))
      p = int(float(pick(row, ["payout","payout_total","return"])))
      bets   += b
      hits   += h
      payout += p
  stake = unit * bets

hit_rate = (hits / races) if races else 0.0
roi = ((payout - stake) / stake) if stake else 0.0

out = {
  "date": date,
  "mode": mode,
  "pid": pid,
  "races": races,
  "bets_total": bets,
  "unit": unit,
  "stake_total": stake,
  "hits": hits,
  "hit_rate": float(f"{hit_rate:.12f}"),
  "payout_total": payout,
  "roi": float(f"{roi:.12f}"),
  "options": opts,
}

out_path = os.path.join(os.environ["OUTDIR"], "pass2", "overall.json")
with open(out_path, "w", encoding="utf-8") as w:
  json.dump(out, w, ensure_ascii=False, indent=2)
print("[overall] wrote", out_path)
PY

      - name: Commit results into repo
        if: always()
        run: |
          set -e
          git config user.name  github-actions
          git config user.email github-actions@github.com
          git add ${{ inputs.OUTDIR }}/pass1 ${{ inputs.OUTDIR }}/pass2 TENKAI/predictions/v1/${{ inputs.DATE }} || true
          git commit -m "sims_integrated: ${{ inputs.MODE }} DATE=${{ inputs.DATE }} PID=${{ inputs.PID }} (overall overwrite)" || echo "nothing to commit"
          git push || true

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sims_outputs_${{ inputs.DATE }}_${{ inputs.PID }}
          path: |
            ${{ inputs.OUTDIR }}/pass1/**
            ${{ inputs.OUTDIR }}/pass2/**
            TENKAI/predictions/v1/${{ inputs.DATE }}/**
