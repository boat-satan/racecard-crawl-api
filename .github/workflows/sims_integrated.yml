name: sims_integrated

on:
  workflow_dispatch:
    inputs:
      DATE:
        description: "YYYYMMDD"
        required: true
        type: string
      PID:
        description: "場コード 01..24（カンマ可, all/空=全場）"
        required: false
        default: "all"
        type: string
      MODE:
        description: "predict or eval"
        required: true
        default: "predict"
        type: choice
        options:
          - predict
          - eval
      SIMS:
        description: "試行回数/レース"
        required: true
        default: "600"
        type: string
      TOPN:
        description: "三連単 TOPN"
        required: true
        default: "18"
        type: string
      UNIT:
        description: "1点あたり(円)"
        required: true
        default: "100"
        type: string
      FILTERS:
        description: "例: require_odds=true,min_ev=1.2,odds_bands=01-09,10-19"
        required: false
        default: ""
        type: string
      KEYMAN:
        description: "例: enable=true,thr=0.7,boost=0.15,aggr=0.0,buy_in_top3=false,buy_thr=0.7"
        required: false
        default: "enable=true,thr=0.7,boost=0.15,aggr=0.0,buy_in_top3=false,buy_thr=0.7"
        type: string
      OUTDIR:
        description: "出力ディレクトリ"
        required: false
        default: "scripts/sims"
        type: string

permissions:
  contents: write

concurrency:
  group: sims-integrated-${{ github.ref }}-${{ inputs.DATE }}-${{ inputs.PID }}
  cancel-in-progress: false

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          set -e
          python -m pip install --upgrade pip
          pip install numpy pandas joblib scikit-learn

      - name: Parse FILTERS & KEYMAN
        id: parse
        env:
          FILTERS: ${{ inputs.FILTERS }}
          KEYMAN:  ${{ inputs.KEYMAN }}
        run: |
          set -euo pipefail
          parse_kvlist () {
            local s="$1"; local prefix="$2"
            IFS=',' read -r -a pairs <<< "$s"
            for kv in "${pairs[@]}"; do
              kv="$(echo "$kv" | xargs)"; [ -z "$kv" ] && continue
              if [[ "$kv" == *"="* ]]; then
                k="$(echo "${kv%%=*}" | tr '[:lower:]' '[:upper:]' | tr -c 'A-Z0-9_' '_' | xargs)"
                v="$(echo "${kv#*=}" | xargs)"
                echo "$prefix$k=$v" >> "$GITHUB_OUTPUT"
              fi
            done
          }
          # filter defaults
          echo "F_REQUIRE_ODDS=false" >> "$GITHUB_OUTPUT"
          echo "F_MIN_EV=0"          >> "$GITHUB_OUTPUT"
          echo "F_ODDS_BANDS="       >> "$GITHUB_OUTPUT"
          echo "F_ODDS_MIN=0"        >> "$GITHUB_OUTPUT"
          echo "F_ODDS_MAX=0"        >> "$GITHUB_OUTPUT"
          echo "F_EXCLUDE_FIRST1=false" >> "$GITHUB_OUTPUT"
          echo "F_ONLY_FIRST1=false"    >> "$GITHUB_OUTPUT"
          echo "F_BUY_IN_TOP3=false"    >> "$GITHUB_OUTPUT"
          echo "F_BUY_THR=0.7"          >> "$GITHUB_OUTPUT"
          # keyman defaults
          echo "K_ENABLE=true"   >> "$GITHUB_OUTPUT"
          echo "K_THR=0.7"       >> "$GITHUB_OUTPUT"
          echo "K_BOOST=0.15"    >> "$GITHUB_OUTPUT"
          echo "K_AGGR=0.0"      >> "$GITHUB_OUTPUT"
          [ -n "${FILTERS:-}" ] && parse_kvlist "$FILTERS" "F_"
          [ -n "${KEYMAN:-}" ]  && parse_kvlist "$KEYMAN"  "K_"

      - name: Normalize PID (all/空→01..24, カンマ整形)
        id: pidnorm
        env:
          PID_IN: ${{ inputs.PID }}
        run: |
          set -euo pipefail
          PID_TRIM="$(echo "${PID_IN:-}" | tr '[:space:]' ' ' | xargs)"
          if [ -z "$PID_TRIM" ] || [ "${PID_TRIM,,}" = "all" ]; then
            ALL=""; for i in $(seq -w 01 24); do ALL="${ALL}${i},"; done
            PID_EXP="${ALL%,}"
          else
            PID_NORM="$(echo "$PID_TRIM" | tr '、，;|' ',')"
            OUT=""
            IFS=',' read -r -a arr <<< "$PID_NORM"
            for p in "${arr[@]}"; do
              p="$(echo "$p" | xargs)"; [ -z "$p" ] && continue
              printf -v two "%02d" "$p"; OUT="${OUT}${two},"
            done
            PID_EXP="${OUT%,}"
          fi
          echo "PID_EXP=$PID_EXP" | tee -a "$GITHUB_OUTPUT"

      - name: Run Pass1 (keyman only)
        env:
          DATE:  ${{ inputs.DATE }}
          PID:   ${{ steps.pidnorm.outputs.PID_EXP }}
          SIMS:  ${{ inputs.SIMS }}
          TOPN:  ${{ inputs.TOPN }}
          OUTDIR: ${{ inputs.OUTDIR }}
        run: |
          set -euo pipefail
          python scripts/sims/sims.py \
            --base public --dates "$DATE" --pids "$PID" \
            --sims "$SIMS" --strategy trifecta_topN --topn "$TOPN" \
            --predict-only --outdir "$OUTDIR"

      - name: Run TENKAI prediction (per PID)
        env:
          DATE: ${{ inputs.DATE }}
          PID_EXP: ${{ steps.pidnorm.outputs.PID_EXP }}
        run: |
          set -euo pipefail
          mkdir -p "TENKAI/predictions/v1/$DATE"
          IFS=',' read -r -a PIDS <<< "$PID_EXP"
          for P in "${PIDS[@]}"; do
            P="$(echo "$P" | xargs)"; [ -z "$P" ] && continue
            echo "[tenkai] $DATE / $P"
            python TENKAI/tenkai_predict_integrated.py --date "$DATE" --pid "$P"
          done

      - name: Show ML CSVs
        run: |
          find TENKAI/predictions/v1/${{ inputs.DATE }} -maxdepth 4 -type f -name '*.csv' | sort || true

      - name: Run Pass2 (SimS integrated with ML)
        env:
          DATE:  ${{ inputs.DATE }}
          PID:   ${{ steps.pidnorm.outputs.PID_EXP }}
          MODE:  ${{ inputs.MODE }}
          SIMS:  ${{ inputs.SIMS }}
          TOPN:  ${{ inputs.TOPN }}
          OUTDIR: ${{ inputs.OUTDIR }}
          # filters
          F_REQUIRE_ODDS:   ${{ steps.parse.outputs.F_REQUIRE_ODDS }}
          F_MIN_EV:         ${{ steps.parse.outputs.F_MIN_EV }}
          F_ODDS_BANDS:     ${{ steps.parse.outputs.F_ODDS_BANDS }}
          F_ODDS_MIN:       ${{ steps.parse.outputs.F_ODDS_MIN }}
          F_ODDS_MAX:       ${{ steps.parse.outputs.F_ODDS_MAX }}
          F_EXCLUDE_FIRST1: ${{ steps.parse.outputs.F_EXCLUDE_FIRST1 }}
          F_ONLY_FIRST1:    ${{ steps.parse.outputs.F_ONLY_FIRST1 }}
          F_BUY_IN_TOP3:    ${{ steps.parse.outputs.F_BUY_IN_TOP3 }}
          F_BUY_THR:        ${{ steps.parse.outputs.F_BUY_THR }}
          # keyman
          K_ENABLE: ${{ steps.parse.outputs.K_ENABLE }}
          K_THR:    ${{ steps.parse.outputs.K_THR }}
          K_BOOST:  ${{ steps.parse.outputs.K_BOOST }}
          K_AGGR:   ${{ steps.parse.outputs.K_AGGR }}
        run: |
          set -euo pipefail
          if [[ "${K_ENABLE,,}" == "false" ]]; then
            K_THR=9.9; K_BOOST=0; K_AGGR=0
          fi
          ARGS_COMMON="--base public --dates $DATE --pids $PID \
            --sims $SIMS --topn $TOPN \
            --keyman-threshold $K_THR --keyman-boost $K_BOOST --keyman-aggr $K_AGGR \
            --ml-root TENKAI/predictions/v1 --outdir $OUTDIR"
          [[ "${F_EXCLUDE_FIRST1,,}" == "true" ]] && ARGS_COMMON="$ARGS_COMMON --exclude-first1"
          [[ "${F_ONLY_FIRST1,,}"    == "true" ]] && ARGS_COMMON="$ARGS_COMMON --only-first1"
          [[ "${F_BUY_IN_TOP3,,}"    == "true" ]] && ARGS_COMMON="$ARGS_COMMON --buy-if-keyman-in-top3 --buy-keyman-threshold $F_BUY_THR"
          if [[ "$MODE" == "predict" ]]; then
            python scripts/sims/sims_integrated.py $ARGS_COMMON --predict-only
          else
            ARGS_FILTER=""
            [[ -n "${F_ODDS_BANDS}" ]] && ARGS_FILTER="$ARGS_FILTER --odds-bands \"$F_ODDS_BANDS\""
            [[ -n "${F_ODDS_MIN}" && "$F_ODDS_MIN" != "0" ]] && ARGS_FILTER="$ARGS_FILTER --odds-min $F_ODDS_MIN"
            [[ -n "${F_ODDS_MAX}" && "$F_ODDS_MAX" != "0" ]] && ARGS_FILTER="$ARGS_FILTER --odds-max $F_ODDS_MAX"
            [[ "${F_REQUIRE_ODDS,,}" == "true" ]] && ARGS_FILTER="$ARGS_FILTER --require-odds"
            [[ -n "${F_MIN_EV}" && "$F_MIN_EV" != "0" ]] && ARGS_FILTER="$ARGS_FILTER --min-ev $F_MIN_EV"
            eval python scripts/sims/sims_integrated.py $ARGS_COMMON --odds-base public/odds/v1 $ARGS_FILTER
          fi

      - name: Aggregate & overwrite overall.json
        env:
          DATE:   ${{ inputs.DATE }}
          MODE:   ${{ inputs.MODE }}
          SIMS:   ${{ inputs.SIMS }}
          TOPN:   ${{ inputs.TOPN }}
          UNIT:   ${{ inputs.UNIT }}
          OUTDIR: ${{ inputs.OUTDIR }}
          F_REQUIRE_ODDS:   ${{ steps.parse.outputs.F_REQUIRE_ODDS }}
          F_MIN_EV:         ${{ steps.parse.outputs.F_MIN_EV }}
          F_ODDS_BANDS:     ${{ steps.parse.outputs.F_ODDS_BANDS }}
          F_ODDS_MIN:       ${{ steps.parse.outputs.F_ODDS_MIN }}
          F_ODDS_MAX:       ${{ steps.parse.outputs.F_ODDS_MAX }}
          F_EXCLUDE_FIRST1: ${{ steps.parse.outputs.F_EXCLUDE_FIRST1 }}
          F_ONLY_FIRST1:    ${{ steps.parse.outputs.F_ONLY_FIRST1 }}
          F_BUY_IN_TOP3:    ${{ steps.parse.outputs.F_BUY_IN_TOP3 }}
          F_BUY_THR:        ${{ steps.parse.outputs.F_BUY_THR }}
          K_ENABLE: ${{ steps.parse.outputs.K_ENABLE }}
          K_THR:    ${{ steps.parse.outputs.K_THR }}
          K_BOOST:  ${{ steps.parse.outputs.K_BOOST }}
          K_AGGR:   ${{ steps.parse.outputs.K_AGGR }}
        run: |
          set -euo pipefail
          mkdir -p "$OUTDIR/pass2"
          cat > "$OUTDIR/pass2/_agg.py" <<'PY'
import os, json, glob
DATE=os.environ["DATE"]; MODE=os.environ["MODE"]
SIMS=int(os.environ["SIMS"]); TOPN=int(os.environ["TOPN"])
UNIT=int(os.environ["UNIT"]); OUTDIR=os.environ["OUTDIR"]
F={"require_odds":os.environ.get("F_REQUIRE_ODDS","false").lower()=="true",
   "min_ev":float(os.environ.get("F_MIN_EV") or 0),
   "odds_bands":os.environ.get("F_ODDS_BANDS",""),
   "odds_min":float(os.environ.get("F_ODDS_MIN") or 0),
   "odds_max":float(os.environ.get("F_ODDS_MAX") or 0),
   "exclude_first1":os.environ.get("F_EXCLUDE_FIRST1","false").lower()=="true",
   "only_first1":os.environ.get("F_ONLY_FIRST1","false").lower()=="true",
   "buy_in_top3":os.environ.get("F_BUY_IN_TOP3","false").lower()=="true",
   "buy_thr":float(os.environ.get("F_BUY_THR") or 0.7)}
K_ENABLE=os.environ.get("K_ENABLE","true").lower()=="true"
K_THR=float(os.environ.get("K_THR") or 0.7)
K_BOOST=float(os.environ.get("K_BOOST") or 0.15)
K_AGGR=float(os.environ.get("K_AGGR") or 0.25)
if not K_ENABLE: K_THR,K_BOOST,K_AGGR=9.9,0.0,0.0
pred_dir=os.path.join(OUTDIR,"pass2","predict")
overall_path=os.path.join(OUTDIR,"pass2","overall.json")
def _norm_race(r): r=(r or "").strip().upper(); return r if (not r or r.endswith("R")) else r+"R"
def _res(date,pid,race):
  base="public"; root_v1=os.path.join(base,"results","v1")
  root=root_v1 if os.path.isdir(root_v1) else os.path.join(base,"results")
  dirp=os.path.join(root,str(date),str(pid))
  cand=os.path.join(dirp,f"{_norm_race(race)}.json")
  if os.path.isfile(cand): return json.load(open(cand,encoding="utf-8"))
  for f in os.listdir(dirp):
    if f.lower().endswith(".json"):
      d=json.load(open(os.path.join(dirp,f),encoding="utf-8"))
      cont=d.get("races",d) if isinstance(d,dict) else {}
      rk=_norm_race(race)
      if rk in cont: return cont[rk]
  return {}
def _hit(d):
  trif=(d or {}).get("payouts",{}).get("trifecta")
  if isinstance(trif,dict): return trif.get("combo"), int(trif.get("amount") or 0)
  order=(d or {}).get("order")
  if isinstance(order,list) and len(order)>=3:
    lane=lambda x: str(x.get("lane") or x.get("course") or x.get("F") or x.get("number"))
    try:
      f,s,t=lane(order[0]),lane(order[1]),lane(order[2]); return f"{f}-{s}-{t}", 0
    except: pass
  return None, 0
files=sorted(glob.glob(os.path.join(pred_dir,"pred_*_*_*.json")))
races=len(files); bets_total=0; stake_total=0; hits=0; payout_total=0
for fp in files:
  d=json.load(open(fp,encoding="utf-8"))
  buylist=d.get("buylist",[])
  bets=len(buylist); bets_total+=bets; stake_total+=bets*UNIT
  if MODE=="eval":
    res=_res(d.get("date"),d.get("pid"),d.get("race"))
    combo,pay=_hit(res)
    if combo and any(combo==it["ticket"] for it in buylist):
      hits+=1; payout_total+=int(pay)
roi=(payout_total-stake_total)/stake_total if (MODE=="eval" and stake_total>0) else 0.0
overall={"date":DATE,"mode":MODE,"races":races,"bets_total":bets_total,
         "unit":UNIT,"stake_total":stake_total,"hits":hits,
         "hit_rate":(hits/races if races>0 else 0.0),
         "payout_total":payout_total,"roi":roi,
         "options":{"sims":SIMS,"topn":TOPN,"filters":F,
                    "keyman":{"enable":K_ENABLE,"threshold":K_THR,"boost":K_BOOST,"aggr":K_AGGR}}}
os.makedirs(os.path.dirname(overall_path), exist_ok=True)
json.dump(overall, open(overall_path,"w",encoding="utf-8"), ensure_ascii=False, indent=2)
print(f"[overall] wrote {overall_path}")
PY
          python "$OUTDIR/pass2/_agg.py"

      - name: Commit results into repo
        if: always()
        run: |
          set -e
          git config user.name  github-actions
          git config user.email github-actions@github.com
          git add ${{ inputs.OUTDIR }}/pass1 ${{ inputs.OUTDIR }}/pass2 TENKAI/predictions/v1/${{ inputs.DATE }} || true
          git commit -m "sims_integrated: ${{ inputs.MODE }} DATE=${{ inputs.DATE }} PID=${{ inputs.PID }}" || echo "nothing to commit"
          git push || true

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sims_outputs_${{ inputs.DATE }}_${{ inputs.PID }}
          path: |
            ${{ inputs.OUTDIR }}/pass1/**
            ${{ inputs.OUTDIR }}/pass2/**
            TENKAI/predictions/v1/${{ inputs.DATE }}/**
